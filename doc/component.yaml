name: Component
owner: bd-core.classes
type: class
supers: [.../mixins.eventHub, .../mixins.watchHub]
sum: >
  base class used to build a user interface components

namespaces:
- name: protected
  sum: protected properties and methods
  d:
  - >
    These properties and methods should only be used by within the implementations of subclasses of Component.
  n:
  - The Backdraft Library reserves all names that begin with "bd".

- name: static
  sum: static properties and methods defined on Component

- name: types
  sum: types used in `Component` machinery

d:
- >
  `Component` abstracts a user interface component. Subclasses derived from `Component` provide a public interface that is
  independent of the DOM, and `Component` provides machinery to aid in constructing the protected implementation
  that bridges the gap between that public interface and the DOM.

  Consider the example of a combo box component. From the view of the application logic,
  a combo box is simply an input mechanism to collect a value from a list of (value, choice-text)
  pairs:

- c: |
    e(ComboBox, {
        list: someList, value: initialValue, watch: {value: valueWatcher}
    });

- >
  The protected implementation of `ComboBox` constructs the DOM tree that presents the user interface
  and responds to DOM events as the user interacts with the component. For an example of a complete combo box implementation
  see [[bd-widgets.ComboBox]https://github.com/altoviso/bd-widgets/blob/master/src/comboBox/ComboBox.js].
- >
  `Component` provides machinery to aid in constructing the protected implementation, including:

- ol:
  - Declarative composition
  - Life cycle management
  - Child management
  - Property managment
  - Event management
  - Focus management
  - IO state and behavior management

- >
  Subclasses derived from `Component` are intended to be based on composition <i>and</i> specialization patterns; a `Component`
  subclass can be defined by:
- ul:
  - composing several other component subclasses
  - specializing/deriving from/subclassing another component class
  - any combination of the above

- section:
    name: Declarative Composition
    id: declarativeComposition
    d:
    - >
      The actualization of a browser-hosted user interface component is a DOM tree or forest. `Component` uses declarative composition
      to describe the structure, properties, and connections of the DOM tree/forest prescribed by a particular `Component` subclass.
      This is to say that the tree/forest is functionally <i>declared</i> as as an abstraction as opposed to being built with actual DOM nodes by an imperative process, and the
      components used in the declaration may be other `Component` subclasses. Here is an example:
    - c: |
        e("div", {className: "renameDialog"},
            e("div",
                e(Labeled, {label:"Current Name", value: this.currentName}),
                e(Labeled, {label:"New Name", value: e(Input, {size:50, bdReflect:"name"})})
            ),
            e("div", {className: "bottomButtons"},
                e(Button, {label: "Cancel"}),
                e(Button, {label: "OK"})
            )
        );

    - >
      The example is from a rename dialog that shows a current name, collects a new name, and provides "OK" and "Cancel" buttons
      to terminate the dialog. See the [[Rename Dialog Example]http://backdraftjs.org/examples/dialog/index.html] for a working example.

      The tree is an abstraction of the the actual DOM tree associated with a particular `Component` instance. The abstraction is composed of .../classes.Element nodes that contain other `Element` nodes; .../functions.e is a factory function that creates such nodes.

    - ul:
      - >
        Each node that has a tag name for the first argument to the `e` factory indicates
        a DOM element (all the `"div"` nodes).
      - >
        Each node that has a constructor function for the first argument indicates a `Component` subclass (`Labeled`, `Input`,
        and `Button`).

    - >
      Subclasses found in the tree will have their own trees of `Element` nodes: this is the <i>composition</i> aspect of the declarative composition design. `Component`'s internal machinery transforms an abstract `Element` tree in to a tree of DOM nodes; this is described in detail below.

    - i:
      - >
        `Component` subclasses may define their DOM as either a single-rooted tree or a multi-rooted forest, and all Component
        machinery is designed and implemented to handle both cases. When rendered, a reference to the DOM created by
        a component is maintained at `<i>instance</i>.bdDom.root` (see ./protected.bdDom). For a single-rooted tree, `bdDom.root`
        will reference a single DOM node; similarly, for a multi-rooted forest, `bdDom.root`
        will reference an array of DOM nodes. Unless there is an important difference between the behavior of a single-rooted
        tree compared to a multi-rooted forest, we shall write in terms of a single-rooted tree for the remainder of Component's
        reference documentation.
    - i:
      - >
        Notice that the entirety of this system resides within the standard JavaScript
        environment. There is never a need to "compile" or otherwise transform an `Element` tree.

    - >
      Since the `Element` tree is declared with standard JavaScript, the full power of the language is available in the
      declaration. There is never the need to "escape" out of a templating/markup language to include state-dependent
      structure/value in the declaration. Here is another example where the structure of the declaration is affected by state:
    - c: |
        e("div", {className:"welcome-message"},
            e("p", `Welcome ${fname} ${lname}`),
                customerProps.important && e("p", {className:"important"}, "We're very happy to see you again!"),
                e("div", {className:"suggestion-list"},
                    e("p", "Please consider buying the following stuff!"),
                    e("ul", customerProps.suggestions.map(item => e("li", item)))
                )
            )
        )
    - >
      The protected method ./protected.bdElements returns the .../classes.Element tree that describes the structure, properties, and connections
      of the DOM tree prescribed by a particular `Component` subclass. An override for `bdElements` is almost-always provided
      in subclass definitions.

      The method ./render transforms the declaration into an actual DOM tree and saves a reference to the root at
      `<i>instance</i>.bdDom.root` (see ./protected.bdDom). The method ./unrender destroys the DOM tree and any resources consequent rendering.
    - i:
      - >
        Life cycle methods like `render` and `unrender` are rarely applied explicitly; this is discussed in the section Typical Life Cycles, later.
- section:
    name: Life Cycle
    id: lifecycle
    d:
    - >
      `Component` instances have the following life cycle states:
    - ol:
      - >
        <b>Unrendered</b>: the component's DOM tree has not been instantiated. ./rendered and ./attachedToDoc are false. The
        component's public API is fully functional according to the semantics of that API. For example, ./addClassName and
        ./removeClassName can be applied to an unrendered component, and when that component is finally rendered,
        the className property of `bdDom.root` (see ./protected.bdDom) will be set accordingly. Of course some public functions are nonsensical
        when applied to an unrendered component. For example, ./focus simply results in a no-op when applied to an unrendered component.
      - >
        <b>Rendered</b>: the component's DOM tree has been instantiated, but not attached to the document. ./rendered
        is true, but ./attachedToDoc is false.
      - >
        <b>Attached</b>: the component's DOM tree has been instantiated and is attached to the document body. ./rendered
        and ./attachedToDoc are both true.
      - >
        <b>Destroyed</b>: ./destroy has been applied to the component. The component's DOM tree has
        been destroyed (if it was ever rendered) and all resources (handles to watchers and events, references to dom nodes, etc.) have
        been destroyed. Once destroyed, the component instance is in an irreversible dead state that should be easily marked
        for garbage collection by the JavaScript runtime environment.
    - >
      Upon creating an component ("newing" up a component type), the component is in the unrendered state. A component
      may transition to/from the rendered and/or attached states any number of times by applying life cycle
      methods with the exception of ./destroy (see above).
    - i:
      - >
        Remember, life cycle methods like render and unrender are rarely applied explicitly; this is discussed in the section Typical Life Cycles, later.
    - n:
      - >
        Applying ./destroy to a `Component` instance is not strictly required to ensure garbage collection of an instance that
        is no longer in use <i>so long as all references to that instance have been deleted</i>. The most common places to
        miss references to a `Component` instance are found in event handler and watcher connections that reference the component.
        So long as handlers and watchers are connected through .../mixins.eventHub.advise and .../mixins.watchHub.watch, all connections will be automatically
        destroyed by ./destroy. This is the raison d'Ãªtre for ./destroy.

- section:
    name: Child Managment
    id: childManagement
    d:
    - >
      `Component` instances may contain other `Component` instances. These other instances are termed "children" and an instance
      that contains a child is termed the "parent" of that child. ./insChild and ./delChild allow children to be explicitly
      inserted/deleted to/from the children collection of a parent. While these methods are useful for some `Component` subclasses
      that implement collections like lists and grids, usually children are created, rendered, and inserted automatically when a parent
      is rendered as a consequence of the parent's `Element` tree containing `Component` nodes. Recall the rename element tree we saw earlier; here it is in a more-complete context.
      It contains four children--two `Labeled` instances and two `Button` instances.
    - c: |
        class RenameDialog extends Dialog {
            bdElements(){
                return e("div", {className: "renameDialog"},
                    e("div",
                        e(Labeled, {label:"Current Name", value: this.currentName}),
                        e(Labeled, {label:"New Name", value: e(Input, {size:50, bdReflect:"name"})})
                    ),
                    e("div", {className: "bottomButtons"},
                        e(Button, {label: "Cancel"}),
                        e(Button, {label: "OK"})
                    )
                );
            }

            // other stuff...
        }

        // such a dialog may be used like this...

        Dialog.show(RenameDialog, {currentName: theCurrentName}).then(
            result => {
              if(result){
                  // result is the new name...rename whatever
              }//else the dialog was canceled
            }
        );
    - >
      Notice how `bdElements` in the example above describes a DOM tree <i>and</i> a set of `Component` instances used to
      "decorate" that tree. All children mentioned in the ../Element tree given by ./protected.bdElements are automatically
      instantiated and rendered when the parent component is rendered. Naturally, each child instance
      provides its own DOM tree and decorations and so on until the component instance is completely rendered. This
      is a good example of a `Component` subclass that is both a specialization of another `Component` subclass, namely `Dialog`,
      and a composition of other `Component` subclasses, namely `Labeled` and `Button`.

      When children instances are created implicitly during rendering as given by ./protected.bdElements, the root of a particular
      child's DOM tree is appended to the parent DOM node as given by the `Element` tree; this is obvious from the example
      above. When a child is explicitly inserted with ./insChild, the child may be appended to the parents DOM tree at
      several different locations. See ./insChild for details.

      Children may exist <i>only</i> when the parent is rendered. All children of a particular parent are automatically
      destroyed when that parent is unrendered. If this default behavior is not appropriate for a particular subclass
      design, an override to unrender can be provided; for example:
    - c: |
        unrender(){
            this.cachedChildren = this.children.map(child => this.delChild(child, true));
            super.unrender();
        }
    - >
      By applying ./delChild with a `preserve` argument of true, the child will be preserved (not destroyed) upon removing
      it from the children collection (see ./delChild). Presumably, `cachedChildren` would be used in some way by other
      parts of the implementation--almost certainly during ./render. Caching designs can be used to dramatically improve
      performance for certain kinds of components.

      ./insChild and ./delChild are most often used in `Component` subclasses that present collections, for example lists and
      grids. Since collections ofter require some kind of re-ordering functionality, `Component` provides ./reorderChildren,
      which allows the children of a parent to be reordered in-place. This machinery is <i>the most performant</i> design
      theoretically possible; hand-tuned designs will be no faster.

      Owing to the design of Component's child management machinery, rendering and unrendering a particular `Component` instance
      automatically creates, renders, unrenders, and destroys that instance's children as the instance lives its lifetime.
      Therefore constructing an application is a matter of explicitly rendering a top-level component and then allowing
      that component to insert/remove children as required given user stimulation and that component's semantics.
      Each parent will manage its own children semantics similarly. Indeed, many kinds of applications include a single,
      explicit render of the top-level component instance.

- section:
    name: Typical Life Cycles
    id: typicalLifeCycles
    d:
    - >
      The following examples demonstrate the typical methods used to manage life cycles. In the examples
      `Panel` is a subclass of `Component` that implements a home automation dimmer panel interface; `panel` is an instance
      of `Panel`. Similarly, `TopFrame` is a subclass  that implements the top container of a home automation application
      and `top` is an instance of `TopFrame`.

    - ol:
      - - >
          An application creates, renders, and attaches a single `Component` instance with the ./render
          function:
        - c: |
            let top = render(e(TopFrame), "root");
      - - >
          Children are created, rendered, and attached to existing Components with ./insChild:
        - c: |
            let panel = top.insChild(e(Panel, {id:"bathroom"}));
      - - >
          Children are detached, unrendered, and destroyed with ./delChild:
        - c: |
            top.delChild(panel);
            // panel is dead forever
      - - >
          Children can be detached and unrendered, but not destroyed by providing `true` for the `preserve` argument
          of ./delChild.
        - c: |
            top.delChild(panel, true);
            // panel can be rendered/attached again at some time in the future
      - - >
          Usually, children are inserted consequent to some event caused by the user:
        - c: |
            globalEventGenerator.advise(
              "onPanelDemand", (panelId) => top.insChild(e(Panel, {id:panelId})));
      - - >
          Putting this all together, the `"onPanelDemand"` event handler may cache panels, perhaps, something like this:
        - c: |
            let panelCache = {};
            let currentPanel = 0;
            globalEventGenerator.advise("onPanelDemand", (panelId) => {
                top.delChild(currentPanel, true);
                currentPanel =
                    panelCache[panelId] =
                        top.insChild(panelCache[panelId] || e(Panel, {id:panelId}));
            });

    - >
      Most applications use the methods demonstrated above most of the time. However, there are many additional methods
      to create, render, unrender, attach, detach, and destroy `Component` instances. See ./constructor, ./render,
      ./unrender, ./insChild, and ./delChild for further details.

- section:
    name: Property Managment and Protected Names
    id: propManagement
    d:
    - >
     `Component` inherits the mixin class .../mixins.watchHub, which provides an interface to register property watchers and fire mutation notifications to those watchers. Here's how this works: For each <i>watchable</i> public property name, a `Component` subclass defines an associated protected name that is unlikely to clash with any potential public name--public names that may be desirable not only in the subclass being defined, but also in any potential subclasses of the subclass. All Backdraft-defined protected names begin with the prefix "bd", for example, "bdElements", "bdClassName", "bdHasFocus", and so on. The actual, protected property value is stored at the protected name. Then a getter, and, if the property is mutable, a setter are provided to give public access to the protected property. Finally, .../mixins.watchHub.protected.bdMutate is used to detect and signal mutations. For example, here is how the public property "foo" could be implemented in an imaginary Backdraft component.

    - c: |
        class SomeComponent extends Component{
            set foo(){
                this.bdMutate("foo", "bdFoo", value);
            }
            get foo(){
                return this.bdFoo;
            }
        }

        let c = new MyComponent();
        c.watch("foo", (newValue, oldValue) => console.log("***", newValue, oldValue));

        c.foo = "bar" // => *** "bar" undefined
        c.foo = "baz" // => *** "baz" "bar"
        c.foo = "baz" // "baz"==="baz" => the watcher is not applied
    - i:
      - >
        The example uses "bd" to prefix "foo" when defining the protected property address; this prefix is reserved by the
        Backdraft library and client code should choose another prefix. Prefixes should be selected so they are likely
        universally unique.
    - n: >
        Either or both of the public and private property name can be `symbol`s

    - In this pattern, we say...
    - ol:
      - >
        `bdFoo` is a protected property
      - >
        `foo` is a public property
      - >
        `foo` reflects `bdFoo`
      - >
        `bdFoo` is reflected by `foo`

    - Noice that, but <i>not</i> supplying a getter, a public property could be made read-only while the protected property
      remains mutable. This is a common pattern where a public property reflects an internal state, but that internal state
      is only allowed to be changed by some internal process. This idea can be taken a step further
      where the protected property doesn't exist at all and the read-only public property is a reflection of some internal
      state calculation.

    - Here is a list of the public properties defined by `Component` together with the protected properties/state, they reflect.

    - table:
      - - >
          ./id
          - >
          read-only property defined at construction
      - - >
          ./rendered
          - >
          !!./protected.bdDom, bdDom exists iff the component has been rendered
      - - >
          ./attachedToDoc
          - >
          ./protected.bdAttachedToDoc
      - - >
          ./className
          - >
          ./protected.bdClassName
      - - >
          ./hasFocus
          - >
          ./protected.bdHasFocus, automatically set by .../variables.focusManager
      - - >
          ./enabled
          - >
          !./protected.bdDisabled
      - - >
          ./disabled
          - >
          ./protected.bdDisabled
      - - >
          ./tabIndex
          - >
          ./protected.bdTabIndex
      - - >
          ./visible
          - >
          reflects/mutates "bd-hidden" in ./className
      - - >
          ./title
          - >
          ./protected.bdTitle
- section:
    name: Event Managment
    id: eventManagement
    d:
    - >
      `Component` inherits the mixin class .../mixins.eventHub, which provides an interface to register event handlers and fire event notifications to registered handlers. `Component` does not define any events itself. See .../mixins.eventHub.advise and .../mixins.eventHub for further details.


types:
- name: ConstructorKeywordArgs
  sum: keyword-arguments consumed by Component's constructor
  def: |
    interface ConstructorKeywordArgs {
        id?: any truthy value convertible to string;
        staticClassName?: string;
        className?: string | string[];
        tabIndex?: number | falsey;
        title?: string;
        disabled?: boolean;
        enabled?: boolean;
        elements?: Element | Element[] | () => (Element | Element[]);
        postRender?: () => (Destroyable | Destroyable[] | void);
        overrides?: Hash;
        callbacks?: Hash;
        mix?: Hash;
        [string]: any
        [symbol]: any
    }
  d: See ../constructor.

methods:
- name: constructor
  sum: instance initializer
  order: 1
  sig: (kwargs)
  params:
  - name: kwargs
    type: ./types.ConstructorKeywordArgs
    d: >
      Gives a hash of values from which to initialize instance data. `ConstructorKeywordArgs` lists the properties consumed
      by Component; all other properties may be defined by subclasses according to their own semantics.
  d:
  - >
    Creates a new `Component` instance. A reference to `kwargs` is saved at `this.kwargs`.

    If `kwargs.id.toString()` is a non-empty string, then the instance property `id` is defined with the value `kwargs.id.toString()`; otherwise, the instance property `id` is set to undefined. Note that `id` is read-only for the lifetime of the component instance and can never be mutated after construction.

    Remaining `Component`-defined instance properties are initialized as follows:

  - table:
    - - >
        ./staticClassName
      - >
        `this.constructor.className || ""`
    - - >
        ./className
      - >
       `""`
    - - >
        ./tabIndex
      - >
        `""`
    - - >
        ./title
      - >
        `""`
    - - >
        ./disabled
      - >
        `false`
    - - >
        ./enabled
      - >
        `true`
  - >
    `kwargs` may define properties that override the default values described above as follows:
  - table:
    - - >
        `kwargs.staticClassName`
      - >
        ./staticClassName is initialized to `kwargs.staticClassName`
    - - >
        `kwargs.className`
      - >
        ./className is initialized to `kwargs.className`
    - - >
        `kwargs.tabIndex`
      - >
        ./tabIndex is initialized to `kwargs.tabIndex`
    - - >
        `kwargs.title`
      - >
        ./title is initialized to `kwargs.title`
    - - >
        `kwargs.disabled`
      - >
        ./disabled is initialized to `kwargs.disabled`; ./enabled is initialized to `!kwargs.disabled`; if both `kwargs.disabled` and `kwargs.enabled` are provided, `kwargs.disabled` wins.
    - - >
        `kwargs.enabled`
      - >
        ./enabled is initialized to `kwargs.enabled`; ./disabled is initialized to `!kwargs.enabled`; if both `kwargs.disabled` and `kwargs.enabled` are provided, `kwargs.disabled` wins.
    - - >
        `kwargs.postRender`
      - >
        `this.postRender` is set to `kwargs.postRender`
    - - >
        `kwargs.mix`
      - >
        for each `key` in `Reflect.ownKeys(kwargs.mix)`, `this[key]` is set to `kwargs.mix[key]`. This allows per-instance overrides of any method or property and/or the ad hoc addition of per-instance methods/properties at construction.
    - - >
        `kwargs.callbacks`
      - >
        for each `watchableProp` in `Reflect.ownKeys(kwargs.callbacks)` that is also contained in the array `this.constructor.watchables`, .../mixins.watchHub.watch is applied to `(watchableProp, kwargs.callbacks[watchableProp])`<br><br>for each `eventType` in `Reflect.ownKeys(kwargs.callbacks)` that is also contained in the array `this.constructor.events`, .../mixins.eventHub.advise is applied to `(eventType, kwargs.callbacks[eventType])`<br><br>see ./static.watchables and ./static.events

  - >
    Subclasses of `Component` may override or define addition semantics on `kwargs` as required by the design of the subclass.

    Upon construction, an instance is in the unrendered state.
- name: destroy
  sum: >
    destroys all resources and references owned by the instance
  sig: () => void
  d:
  - >
    Destroy all resources and references owned by the instance, thereby making the instance
    readily available for garbage collection. In particular, the following is accomplished:
  - ul:
    - Unrenders the instance (if rendered) and destroys all resources (DOM nodes, event connections, etc.)
      acquired during the time the component was rendered.
    - Destroys all watchers on instance properties.
    - Destroys all handlers on instance events.
    - Destroys all .../types.Destroyable instances published to ./own.
    - Deletes `this.kwargs`.
- name: render
  sum: >
    creates the DOM tree and renders all children given by ./protected.bdElements
  order: 1
  sig: (callback) => void
  params:
  - name: callback
    type: ?, () => (.../types.Destroyable | .../types.Destroyable[] | void)
    d: >
      if provided, applied after the instance is rendered. Any .../types.Destroyable instances returned are applied to ./ownWhileRendered.
  d:
  - >
    If the instance is already in the rendered state, then no-op; otherwise:
  - ol:
    - Generate the ../Element tree(s) by applying ./protected.bdElements.
    - Create the DOM tree(s) decribed by the `Element` tree(s) generated in Step 1.
    - Store the new tree(s) at `bdDom.root` (see ./protected.bdDom).
    - Publish the new tree(s) in the `Component` catalog (see ./static.get).
    - Apply ./postRender.
    - Apply `callback` (if provided).
  sa: ./unrendered, ./rendered

- name: postRender
  sum: executes processing after the creation of the DOM tree(s)
  sig: () => handles
  params:
  - name: handles
    type: .../types.Destroyable |.../types.Destroyable[]
    d: >
      see description
  d:
  - >
    Upon entry to `postRender` the DOM tree(s) associated with the instance have been created and their root(s) stored at
    `bdDom.root` (see ./protected.bdDom). The default implementation of `postRender` is a no-op. See ./render for further details.

    Any handles returned by `postRender` are applied to ./ownWhileRendered.



- name: unrender
  sum: >
    destroys all children and destroys the DOM tree associated with the instance
  order: 2
  sig: () => void
  d:
  - >
    If the instance is in the unrendered state, then no-op; otherwise:
  - ol:
    - >
      Deletes the Component's tree(s) from the `Component` catalog (see ./static.get):
    - >
      Deletes itself by applying ./delChild on itself to its parent (if any).
    - >
      Destroys all of its own children by applying ./destroy to every child in its children collection.
    - >
      Destroys all destroyable objects collected by ./ownWhileRendered.

  - w: >
      Subclasses of `Component` that create children which are not managed by the children collection (an atypical practice)
      usually provide an override to unrender that ensures such children are properly destroyed.

- name: own
  sum: >
    ensures Destroyable instances are destroyed when the instance is destroyed
  order: 2
  sig: (...args) => void
  params:
  - name: arg
    type: .../types.Destroyable
    d: >
      .../types.Destroyable instance to be destroyed upon component destruction.
  - name: arg
    type: (.../types.Destroyable | falsey)[]
    d: >
      array of .../types.Destroyable instances to be destroyed upon component destruction; any falsey elements are ignored.
  - name: arg
    type: falsey
    d: >
      ignored
  d:
  - >
    `own` simplifies management of destroyable resources (e.g., the objects returned by .../mixins.watchHub.watch, .../mixins.eventHub.advise, .../functions.connect)
    by guaranteeing such resources are destroyed upon component destruction. All methods that return destroyable instances
    automatically apply those instances to `own`. Client code can leverage `own` to manage destroyable resources that are
    created by machinery outside of Component's implementation. For example:
  - c: |
      let child = someParent.insChild(SomeChildType, {/* ... */});
      child.watch("someChildProperty", (newValue) => {/* ... */});
      child.own(
          globalEventGenerator.advise(
              "someEvent", child.someMethodThatProcessesSomeEvent.bind(child)
          )
      );
  - >
    In the example above, notice that it was not necessary to apply `own` to the result of `child.watch` since the design of Component
    takes care of that task automatically; on the other hand, there is no way for child to know about the destroyable event
    handler that was connected by `globalEventGenerator.advise`; therefore, `own` is called explicitly. Consequent to this
    application, when child is destroyed, the event handler will automatically be destroyed.

- name: ownWhileRendered
  sum: >
    Ensures Destroyable instances are destroyed when the instance is unrendered
  order: 2
  sig: (...args) => void
  params:
  - name: arg
    type: .../types.Destroyable
    d: >
      .../types.Destroyable instance to be destroyed upon component destruction.
  - name: arg
    type: (.../types.Destroyable | falsey)[]
    d: >
      array of .../types.Destroyable instances to be destroyed upon component destruction; any falsey elements are ignored.
  - name: arg
    type: falsey
    d: >
      ignored
  d:
  - >
    `ownWhileRendered` functions similarly to ./own except that any .../types.Destroyable instances are collected and destroyed between
    ./render and ./unrender.

- name: insChild
  sum: >
    inserts a child component into the children collection
  sig:
  - (element, node, position) => insertedChild
  - (ComponentSubclass, kwargs, node, position) => insertedChild
  - (child, node, position) => insertedChild
  params:
  - name: element
    type: ../Element
    d: >
      child to be inserted is created as `new Component({elements:element})`
  - name: node
    type: ?, DOM node | string
    d: >
      the reference node to attach the child's root(s); if a string is provided, then node is computed as
      `document.getElementById(node)`; see position
  - name: position
    type: ?, .../types.Position
    d: >
      if missing, defaults to "last"
      <br><br>
      first, last => attach the child's DOM root(s) as the first/last children of node
      <br><br>
      before, after => attach the child's DOM root(s) as before/after siblings of node
      <br><br>
      only => attach the child's DOM root(s) as the sole child of node after removing and destroying any existing children
      of node
      <br><br>
      replace => attach the child's DOM root(s) in the position that node exists with respect to it's siblings; remove
      and destroy node
  - name: ComponentSubclass
    type: function
    d: >
      a constructor function that creates an instance of Component; child to be inserted is `new ComponentSubclass(kwargs)`
  - name: kwargs
    type: ./types.ConstructorKeywordArgs
    d: >
      keyword arguments to be provided to ComponentSubclass during construction; if `kwargs` is missing, then `{}` is provided by default
  - name: child
    type: instance of ../Component
    d: >
      the child to be inserted
  - name: insertedChild
    type: instance of ../Component
    d: >
      the child that was inserted
  d:
  - >
    Creates a new component (if an `element` or `ComponentSubclass` was provided), deletes the child from its current parent (if `child`
    was provided that has a parent), renders the child (if necessary), inserts the child DOM root(s) into the instance DOM
    tree, and pushed child into ./children. If the instance is attached to the document,
    ./protected.bdAttachToDoc is applied on the child.

    If `node` is provided, then the DOM root(s) of the new child are inserted with respect to `node`
    as give by `position`; see the description of the `position` parameter, above.

    If node is not provided, then the DOM root(s) of the new child are appended to the first node that exists from the following
    choices:
  - ol:
    - >
      `child.bdParentAttachPoint`; see ./protected.bdParentAttachPoint
    - >
      `this.bdChildrenAttachPoint`; see ./protected.bdChildrenAttachPoint
    - >
      `this.bdDom.root`; see ./protected.bdDom
  - Note that an instance must be rendered before attempting to insert children.

- name: delChild
  sum: >
    deletes a child component from the children collection
  sig:
  - (child, preserve) => deletedChild
  params:
  - name: child
    type: ../Component
    d: >
      the child to delete
  - name: preserve
    type: ?, boolean
    d: >
      if truthy, then ./destroy is <i>not</i> applied to the child; otherwise ./destroy is applied to the child
  - name: deletedChild
    type: .../classes.Component
    d: >
      the deleted child (if any)
  d:
  - >
    If the child does not exist in the children collection, then no processing occurs and `false` is returned; this is not
    considered an error. Otherwise...

    The child's dom root(s) are removed from the instances's DOM tree, `false` is applied to ./protected.bdAttachToDoc on the
    child, and the child is deleted from ./children. If preserve is `true`, then the child is returned
    with no other processing (the child will be in the rendered state). If preserve is `false`, then ./destroy is applied to
    the child and `false` is returned.
  - n:
    - >
      Notice that false is returned in two cases: (1) the child does not exist in the children collection, (2) the child
      was destroyed. Since a destroyed `Component` instance has no internal state and cannot be further manipulated, there is
      no purpose in returning such an instance.


- name: containsClassName
  sum: >
    tests ./className for the presence of a value
  sig:
  - (value) => boolean
  params:
  - name: value
    type: string
    d: >
      the component string to test
  return:
  - >
    `true` if value is contained in `this.className`, false otherwise
  d:
  - >
    `this.className` must contain the complete component given by `value`. Consider the following example:
  - c: |
      let c = new Component({});
      c.className = "foofoo bar baz";
      c.containsClassname("foofoo");      // => true
      c.containsClassname("foo");         // => false
      c.containsClassname("foo bar");     // => false
      c.containsClassname("foofoo bar");  // => true
      c.containsClassname("bar");         // => true
      c.containsClassname("bar baz");     // => true
      c.containsClassname("baz bar");     // => false!!

- name: addClassName
  sum: >
    adds one or more string components to ./className
  sig:
  - (...args) => this
  params:
  - name: arg
    type: string
    d: >
      a component to add
  - name: arg
    type: (string | falsey)[]
    d: >
      zero or more components to add
  - name: arg
    type: falsey
    d: >
      ignored
  return:
  - this
  d:
  - >
    Adds all of the string components provided by `args` to ./className. Multiples of the same component are only added once.
    If a component is provided that already exists in the ./className, then that component is not added again. For example:
  - c: |
      let c = new Component({});
      c.className = "foo";
      c.className;            // => "foo";
      c.addClassName("foo");
      c.className;            // => "foo";
      c.addClassName("bar");
      c.className;            // => "foo bar";
      c.addClassName("baz",
        false,
        ["this", 0, false, null],
        "bar", "foofoo"
      );
      c.className;            // => "foo bar this foofoo";

- name: removeClassName
  sum: >
    removes one or more string components from ./className
  sig:
  - (...args) => this
  params:
  - name: arg
    type: string
    d: >
      a component to add
  - name: arg
    type: (string | falsey)[]
    d: >
      zero or more components to add
  - name: arg
    type: falsey
    d: >
      ignored
  return:
  - this
  d:
  - >
    Removes all of the string components provided by `args` from ./className. No error is generated when ./className does
    not contain a target component. Components are broken down to their word atoms before attempting remove, so removing
    "foo bar" will remove the same components as "bar foo", and either "foo bar" or "bar foo" will remove all components
    from either "foo bar" or "bar foo".

- name: toggleClassName
  sum: >
    adds or removes one or more string components for ./className
  sig:
  - (...args) => this
  params:
  - name: arg
    type: string
    d: >
      a component to add
  - name: arg
    type: (string | falsey)[]
    d: >
      zero or more components to add
  - name: arg
    type: falsey
    d: >
      ignored
  return:
  - this
  d:
  - >
    `args` is broken down into a single list of words with no repeats. For each word, `w`, in the list, if `this.containsClassName(w)`
    is true, then `w` is removed from ./className, otherwise, `w` is added to ./className.

- name: focus
  sum: >
    sets focus on the component
  sig:
  - () => void
  d:
  - >
    Applies the DOM node method `focus()` to the node in the component's DOM tree that has a non-empty `tabIndex` property.

- name: reorderChildren
  sum: >
    reorder children in-place
  sig:
  - (children) => void
  params:
  - name: children
    type: .../classes.Component[]
    d: >
      `this.children`, reordered as desired
  d:
  - >
    This method requires all children passed in `children` have the same DOM node parent for their root DOM nodes. The children root DOM nodes are reordered as given by `children`.


props:
- name: id
  jstype: ro, string | undefined
  sum: the instance if (if any); otherwise, undefined
    unique identifier for the `Component` instance
  d:
  - >
    A unique identifier for the `Component` instance; reflected to `bdDom.root.id` (see ./protected.bdDom) when the instance is rendered.

- name: parent
  jstype: row, Component | undefined
  sum: >
    the `Component` instance which holds this instance in its children collection.
  d: >
    The `Component` instance which holds this instance in its children collection (if any); otherwise, undefined.
  sa: ./protected.bdAdopt, ./insChild, ./delChild, ./childManagement

- name: children
  jstype: row, []Component | undefined
  sum: >
    the list of children contained by the instance
  d: >
    The list of children contained by the instance. Children are only contained when the instance is rendered. If the instance is not rendered or had no children, then `children` is undefined.

- name: rendered
  jstype: row, boolean
  sum:  indicates the rendered state
  d: >
    `true` if the instance is rendered; otherwise `false`. If `rendered` is `true`, ./protected.bdDom will be defined; if `rendered` is `false`, ./protected.bdDom is undefined.

  sa: See ./render, ./unrender, and ./lifecycle.


- name: enabled
  jstype: row, boolean
  sum:  indicates the enabled state
  d: >
    `true` if the instance is enabled; otherwise `false`. If true/false, the CSS class "bd-disabled" as automatically removed/added from/to ./className.

  sa: See ./disabled


- name: disabled
  jstype: row, boolean
  sum:  indicates the !enabled state
  d: >
    `false` if the instance is enabled; otherwise `true`. If false/true, the CSS class "bd-disabled" as automatically added/removed to/from ./className.

  sa: See ./disabled

- name: tabIndex
  jstype: row, integer | ""
  sum:  indicates the tabIndex value
  d: >
    The tabIndex value. When rendered, this value is reflected into the `tabIndex` attribute of the tabIndex node given by `bdDom.tabIndexNode`.; see ./protected.bdDom.

- name: visible
  jstype: row, boolean
  sum:  indicates the visible state
  d: >
    `true` if the instance is visible; otherwise `false`. If true/false, the CSS class "bd-hidden" as automatically removed/added from/to ./className.

- name: attachedToDoc
  jstype: row, boolean
  sum: indicates whether or not the instance's DOM is a descendant of `document.body`
  d:
  - >
    `true` when the instance is rendered and its DOM is a descendant of `document.body`; otherwise, `false`.
  - n:
    - >
      `attachedToDoc` reflects `bdAttachedToDoc`

- name: title
  jstype: rww, string
  sum: >
    reflected into the `title` property of the title node
  d:
  - >
    When a component's ../Element tree (as given by ./protected.bdElements) is rendered, one node in the tree is designated the "title node". A reference to this node is maintained at `bdDom.titleNode` (see ./protected.bdDom). If not explicitly set by some other means, the `bdDom.titleNode` is taken as `bdDom.root`.

- name: className
  jstype: rww, string
  sum: >
    the per-instance className
  d:
  - >
    A sequence of words separated by single spaces that are reflected to `bdDom.root.className` (see ./protected.bdDom) when the instance is rendered. The property is maintained and may be mutated whether or not the component is rendered.

    When the component is rendered, the concatenation of ./staticClassName and `className` is reflected to
    the DOM root's `className` attribute, and mutating `className` causes the DOM root's `className` attribute to mutate. For example:
  - c: |
      class C1 extends Component {
          bdElements(){
            return e("div");
          }
      }

      // define the static className on the class
      C1.className = "base";

      let c1 = new C1({});
      c1.className;            // ""
      c1.className = "foo";
      c1.render();
      c1.className;            // "foo"
      c1.bdDom.root.className; // "base foo"
      c1.addClassName("bar");
      c1.className;            // "foo bar"
      c1.bdDom.root.className; // "base foo bar"
  - >
    `className` is initialized during construction and may be mutated at any time directly or through the convenience methods
    ./addClassName, ./removeClassName, ./toggleClassName. Further, if a `className` property is provided
    on the root element returned by ./protected.bdElements, then the contents of that property is automatically added to the current
    `className` value when the component is rendered. Here is an example to illustrate this design.

  - c: |
      class C1 extends Component {
          bdElements(){
            return e("div");
          }
      }
      let c1 = new C1({});
      c1.className; // ""
      c1.className = "baz";
      c1.render();
      c1.className; // "baz"

      class C2 extends Component {
            bdElements(){
              return e("div", {className:"foo bar"});
            }
      }
      let c2 = new C2({});
      c2.className; // ""
      c2.className = "baz";
      c1.render();
      c1.className; // "foo bar baz"

  - >
    ./staticClassName is defined at construction (see ./constructor) and is immutable during the lifetime of the
    component; conversely, `className` is mutable in any life cycle state so long as the component is not destroyed. `className`
    does not provide any access--read or write--to ./staticClassName.
  - n:
    - >
      `className` reflects ./protected.bdClassName
  - sa: ./containsClassName, ./addClassName, ./removeClassName, ./toggleClassName, ./staticClassName

- name: staticClassName
  jstype: ro, string
  sum: the static className of the component
  d:
  - >
    `Component` defines a "static className" at construction which may not be mutated during the lifetime of the component. See
    ./constructor for details on initialization. When the component is rendered, the concatenation of `staticClassName` and ./className
    is reflected in the className property of the root node of the component's DOM.

- name: hasFocus
  jstype: row, boolean
  sum: >
    indicates whether or not the component has the focus
  d:
  - >
    When a DOM node is the `document.activeElement` (has the browser focus) and that node is contained in the DOM tree of a component,
    `hasFocus` is true for that component and all of its ancestors; `hasFocus` is false otherwise.
  - n:
    - >
      `hasFocus` reflects ./protected.bdHasFocus; bdHasFocus is mutated by the private methods ./protected.bdOnFocus and ./protected.bdOnBlur which are applied by the .../variables.focusManager.
pProps:
- name: bdClassName
  jstype: rw, string | undefined
  sum: >
    the protected property that holds the actual ./className value
  d:
  - >
    `bdClassName` is mutated by ./protected.bdSetClassName; `bdClassName` is reflected by ./className.
  - w:
    - This is a protected property and is not intended to be accessed by client code.

- name: bdDisabled
  jstype: rw, boolean
  sum: >
    the protected property that holds the actual ./disabled value
  d:
  - >
    `bdDisabled` is reflected by both ./disabled and ./enabled.
  - w:
    - This is a protected property and is not intended to be accessed by client code.

- name: bdTabIndex
  jstype: rw, number | falsey
  sum: >
    the protected property that holds the actual ./tabIndex value
  d:
  - >
    `bdTabIndex` is reflected by ./tabIndex
  - w:
    - This is a protected property and is not intended to be accessed by client code.

- name: bdTitle
  jstype: rw, string | undefined
  sum: >
    the protected property that holds the actual ./title value
  d:
  - >
    `bdTitle` is reflected by ./title
  - w:
    - This is a protected property and is not intended to be accessed by client code.

- name: bdDom
  jstype: rw, object
  sum: >
    the protected property that holds various references pertaining to a component's rendering
  d:
  - >
    `bdDom` holds various references/data pertaining to a component's rendering. `Component` defines the following properties:
  - ul:
    - >
      `bdDom.root`: the root DOM node or nodes of the component's rendering
    - >
      `bdDom.titleNode`: the DOM node to which the ./title property is reflected (./title is reflected to `bdDom.titleNode.title`)
    - >
      `bdDom.tabIndexNode`: the DOM node to which the ./tabIndex property is reflected (./tabIndex is reflected to `bdDom.tabIndexNode.tabIndex`)
    - >
      `bdDom.handles`: the list of .../types.Destroyable objects that have been ./ownWhileRendered.
  - >
    Subclasses of .../classes.Component are free to add to `bdDom` so long as they do not step on already-existing definitions.
  - w:
    - This is a protected property and is not intended to be accessed by client code.

- name: bdParent
  jstype: rw, Component | undefined
  sum: >
    the protected property that holds the actual ./parent value
  d:
  - >
    `bdParent` is reflected by ./parent; bdParent is mutated by internal, protected processes, primarily ./protected.bdAdopt.
  - w:
    - This is a protected property and is not intended to be accessed by client code.

- name: bdHasFocus
  jstype: rw, boolean | undefined
  sum: >
    the protected property that holds the actual ./hasFocus value
  d:
  - >
    `bdHasFocus` is reflected by ./hasFocus; bdHasFocus is mutated by internal, protected processes, primarily ./protected.bdOnFocus
    and ./protected.bdOnBlur.
  - w:
    - This is a protected property and is not intended to be accessed by client code.

- name: bdParentAttachPoint
  jstype: rw, string | symbol
  sum: >
    the location within a parent to attach the component
  d:
  - >
    Gives the property address within a prospective parent object that holds the DOM node to which the component's
    DOM root should be appended.
  - w:
    - This is a protected property and is not intended to be accessed by client code.

- name: bdChildrenAttachPoint
  jstype: rw, Component | undefined
  sum: >
    the location within a parent to attach children
  d:
  - >
    Gives the property address within the component instance that holds the DOM node to which the component
    should append children DOM roots.
  - w:
    - This is a protected property and is not intended to be accessed by client code.

- name: bdAttachedToDoc
  jstype: rw, boolean | undefined
  sum: >
    the protected property that holds the actual ./attachedToDoc value
  d:
  - >
    `bdAttachedToDoc` is reflected by ./attachedToDoc; bdAttachedToDoc is mutated by internal, protected processes, primarily
    ./protected.bdAttachToDoc.
  - w:
    - This is a protected property and is not intended to be accessed by client code.



pMethods:
- name: bdElements
  sum: generate the `Element` tree(s) that describe the components DOM
  sig: () => ../Element | ../Element[]
  d:
  - >
    `bdElements` is applied immediately before rendering the instance to create the `Element` tree(s) that describe the
    structure, properties, and connections of the DOM tree(s) associated with the instance. Typically, classes
    derived from `Component` override `bdElements` to define a particular structure as required by the semantics
    and design of the subclass. `bdElements` may also be overridden on a per-instance basis by providing `kwargs.elements`
    at construction or setting the instance `bdElement` method explicitly.

    The default implementation generates the `Element` tree `new Element("div", {})`.

- name: bdAttachToDoc
  sum: >
    mutates the property ./protected.bdAttachedToDoc; applied recursively to all children
  sig:
  - (attach) => boolean
  params:
  - name: attach
    type: boolean
    d: >
      the new value of ./protected.bdAttachedToDoc
  d:
  - >
    If `attach!==`./protected.bdAttachedToDoc, then mutate bdAttachedToDoc to the new value, recursively apply to all children,
    and return `true`; otherwise, no-op and return `false`.

- name: bdAdopt
  sum: >
    accomplish various internal bookkeeping tasks when a child is added to a component
  sig:
  - (child) => void
  params:
  - name: child
    type: ../Component
    d: >
      the child that is being adopted
  d:
  - ol:
    - Push the child into ./children.
    - Mutate the child's ./parent property to reflect the new parent.
    - If `this.attachedToDoc===true`, than apply true to ./protected.bdAttachToDoc on the child.


- name: bdOnFocus
  sum: >
    applied by .../variables.focusManager when the component or one of its descendants receives the focus
  sig:
  - () => void
  d:
  - >
    This protected method is applied by the .../variables.focusManager when a DOM node within the component's DOM or
    one of its descendants' DOM  receives the focus. The default processing sets ./protected.bdHasFocus to true and executes
    `this.addClassName("bd-focused")`.
  - w:
    - This is a protected method and is not intended to be accessed by client code.

- name: bdOnBlur
  sum: >
    applied by .../variables.focusManager when the component loses the focus
  sig:
  - () => void
  d:
  - >
    This protected method is applied by the .../variables.focusManager when the component has the focus and then the focus moves
    to a component other than itself or one if its descendants. The default processing sets ./protected.bdHasFocus to false and
    executes `this.removeClass("bd-focused")`.
  - w:
    - This is a protected method and is not intended to be accessed by client code.

- name: bdSetClassName
  sum: >
    mutates ./protected.bdClassName and signals all ./className watchers
  sig:
  - (newValue, oldValue) => void
  d:
  - >
    Mutates ./protected.bdClassName and signals all ./className watchers.
  - w:
    - This is a protected method and is not intended to be accessed by client code.

sProps:
- name: events
  jstype: (string | symbol)[]
  sum: list of events defined by Component
  d:
  - >
    As a best practice, all Backdraft-defined classes derived from `eventHub` define the list of event names which the class may notify. This list is a static property located at `events`.



- name: watchables
  jstype: (string | symbol)[]
  sum: list of watchable properties defined by Component
  d:
  - >
    As a best practice, all Backdraft-defined classes derived from `watchHub` define the list of property names which are watchabe. This list is a static property located at `watchables`.

sMethods:
- name: get
  sum: resolve a `Component` instance from a DOM node
  sig: (node) => Component | undefined
  d:
  - >
    Given a DOM node that is the root of a `Component` instance, returns that instance; undefined otherwise.
- name: withWatchables
  jstype: mixin
  sum: .../mixins.withWatchables with superclass===`Component`
  d:
  - >
    Syntax sugar:

    `class MyClass extends Component.withWatchables(<i>propertyDefs</i>) { /* ... */ }`

    is equivalent to

    `class MyClass extends withWatchables(Component, <i>propertyDefs</i>) { /* ... */ }`

    It's not shorter, but it reads better.