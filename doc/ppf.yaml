- name: bdReflect
  owner: bd-core.post-processing-functions
  type: function
  sum: reflect a watchable into a property of `ppfTarget`
  sig:
  - (watchable, prop, formatter)
  params:
  - name: watchable
    type: ?, ../mixins.watchHub | ../types.Watchable
    d: >
      the object that contains the watchable property, if missing, `ppfOwner` is assumed
  - name: prop
    type: string | symbol
    d: >
      the property to reflect
  - name: formatter
    type: ?, function(any) => any
    default: >
      `x => x`
    d: >
      formatter to apply to `watchable[prop]` during reflection
  d:
  - >
    `bdReflect` takes a hash from property is `ppfTarget` (see ../post-processing-functions for a definition `ppfTarget`) to a formatted watchable that is reflected into that property. To be reflected means that the property is initialized with the formatted value of `watchable[prop]` when `ppfTarget` is created and further, the property is updated to reflect the current formatted value of `watchable[prop]` any time the formatted value of `watchable[prop]` mutates. For example, consider the following component:

  - c: |
      class MyComponent extends Component.withWatchables("myProp") {
          bdElements(){
              e("div", {bdReflect: {innerHTML: [this, "myProp", v => v ? v : "?"]});
          }
      }
  - >
    The `innerHTML` of the `DIV` node will be initialized to `this.myProp ? this.myProp : "?"` and any time that the value `this.myProp ? this.myProp : "?"` mutates, `innerHTML` will be updated accordingly.

    When reflecting a property in the `ppfOwner` (see ../post-processing-functions for a definition `ppfOwner`), the watchable argument may be omitted. The following is equivalent to the original example:

  - c: |
      bdElements(){
          e("div", {bdReflect: {innerHTML: ["myProp", v => v ? v : "?"]);
      }

  - >
    As described in ../post-processing-functions, when the value of a function in `ppFuncs` is a hash, as in the case of `bdReflect`, the underscore optimization may be employed. The following is equivalent to the original example:

  - c: |
      bdElements(){
          e("div", {bdReflect_innerHTML: ["myProp", v => v ? v : "?"]);
      }
  - >
    `bdReflect` includes an extra expressive optimization by assuming `innerHTML` if the target property is missing. The following is equivalent to the original example:

  - c: |
      bdElements(){
          e("div", {bdReflect: ["myProp", v => v ? v : "?"]);
      }
  - >
    As noted in `bdReflect`'s signature, the formatter is always optional. So the common case of reflecting a property value in a component into the `innerHTML` without formatting can be stated quite tersely as follows:

  - c: |
      bdElements(){
          e("div", {bdReflect: "myProp");
      }

- name: bdAdvise
  owner: bd-core.post-processing-functions
  type: function
  sum: connect an event handler to an event on `ppfTarget`
  sig: (handler)
  params:
  - name: handler
    type: function(eventObject) =>  void
    d: >
      the handler to apply when event is signaled
  d:
  - >
    `bdAdvise` takes a hash from event type to handler function. When `ppfTarget` (see ../post-processing-functions for a definition of `ppfTarget`) is a DOM node, the event is connected with ../functions.connect; when `ppfTarget` is a `component`, the event is connected with ../mixins.watchHub.advise. For example, consider:

  - c: |
      class MyClass extends Component {
          bdElements(){
              return e("div",
                  e("div", {bdAdvise: {click: this.onClick.bind(this)}}),
                  e(AnotherComponent, {bdAdvise: {someEvent: this.onSomeEvent.bind(this)}})
              };
          }
      }

  - >
    The `bdAdvise` for the freshly-created `DIV` node, `node`, causes the following connection:
  - c: |
      owner.ownWhileRendered(connect(node, "click", this.onClick.bind(this)))
  - >
    And the `bdAdvise` for freshly-instantiated `AnotherComponent` instance, `instance`, causes the following connection:
  - c: |
      owner.ownWhileRendered(instance.advise("someEvent" this.onClick.bind(this)))
  - >
    If a `string` or `symbol` is given for the handler, then `ppfOwner[handler]` is assumed (see ../post-processing-functions for a definition of `ppfOwner`). For example:
  - c: |
      e("div", {bdAdvise: {click: "onClick"}})
  - >
    is equivalent to
  - c: |
      e("div", {bdAdvise: {click: this.onClick.bind(this)}})
  - >
    As described in ../post-processing-functions, when the value of a function in `ppFuncs` is a hash, as in the case of `bdAdvise`, the underscore optimization may be employed. The following is equivalent to `DIV` connection in the original example:

  - c: |
      e("div", {bdAdvise_click: "onClick"})
  - >
- name: bdAttach
  owner: bd-core.post-processing-functions
  type: function
  sum: attach a reference to `ppfTarget`
  sig:
  - (prop)
  - (func)
  params:
  - name: prop
    type: string | symbol
    d: >
      property in `ppfOwner` to initialize with a reference to `ppfTarget`
  - name: func
    type: function(ppfOwner) => void
    d: >
      function to receive a reference to `ppfTarget`
  d:
  - >
    The first form causes the following processing:
  - c: |
      ppfOwner[prop] = ppfTarget;
      ppfOwner.ownWhileRendered({
      	destroy: function(){
      		delete ppfOwner[prop];
      	}
      });
  - >
    The second form causes the following processing:
  - c: |
      func(ppfTarget);
- name: bdWatch
  owner: bd-core.post-processing-functions
  type: function
  sum: connect a watcher to a watchable property in `ppfTarget`
  sig:
  - (watcher)
  - (prop)
  params:
  - name: watcher
    type: ../types.Watcher
    d: >
      the watcher to connect
  - name: prop
    type: string | symbol
    d: >
      the watcher to connect is given by `ppfOwner[prop]`
  d:
  - >
    `ppfTarget` must be a ../classes.Component. See ../post-processing-functions for definitions of `ppfOwner`, `ppfTarget`, and `ppfProcId`.

    The first form causes the following processing:
  - c: |
      ppfOwner.ownWhileRendered(ppfTarget.watch(ppfProcId, watcher))
  - >
    The second form causes the following processing:
  - c: |
      ppfOwner.ownWhileRendered(ppfTarget.watch(ppfProcId, ppfOwner[prop].bind(ppfOwner))

- name: bdTitleNode
  owner: bd-core.post-processing-functions
  type: function
  sum: sets `bdDom.titleNode` to `ppfTarget`
  d:
  - >
    Sets `bdDom.titleNode` to `ppfTarget`. See ../post-processing-functions for definitions of `ppfTarget`. See ../classes.Component.title for details about how a title is reflected.

- name: bdChildrenAttachPoint
  owner: bd-core.post-processing-functions
  type: function
  sum: designates `ppfTarget` as the node to which children are attached
  d:
  - >
    Designates `ppfTarget` as the node to which children are attached. See ../post-processing-functions for definitions of `ppfTarget`.

- name: bdReflectClass
  owner: bd-core.post-processing-functions
  type: function
  sum: reflects one or more formatted watchables into `ppfTarget.className`
  sig: (watchable, prop, formatter, ...)
  params:
  - name: watchable
    type: ?, ../mixins.watchHub | ../types.Watchable
    d: >
      the object that contains the watchable property, if missing, `ppOwner` is assumed
  - name: prop
    type: string | symbol
    d: >
      the property to reflect
  - name: formatter
    type: ?, function(any) => any
    default: >
      `x => x`
    d: >
      formatter to apply to `watchable[prop]` during reflection
  d:
  - >
    Reflects one or more formatted watchables into `ppfTarget.className`. Each (watchable, prop, formatter) is a completely separate reflection. For example:

  - c: |
      class MyClass extends Component.withWatchables("error", "value") {
          bdElements(){
              return e("div" {
                  bdReflectClass:[this, "error", v => v ? "error" : "", this, "value", v = v=="" ? "no-value" : ""]},
                  /* children go here */
              );
          }
      }

  - >
    The two CSS classes, namely "error" and "no-value", will be added/removed from the `className` property on the `DIV` depending upon the `error` and `value` property values of a particular `MyClass` instance when that instance is rendered.

    Since the `prop` argument is <i>always</i> required, it is possible to omit optional arguments. For example:

  - c: |
      bdReflectClass:[
          this, "p1", v => v ? "p1" : "", // all three args
          "p2", "p2", v => v ? "p2" : "", // missing first arg; equivalent to (this, "p1", v => v ? "p1" : "")
          this, "p3",                     // missing last arg; equivalent to (this, "p1", x => x)
          "p4"]                           // missing first and last arg; equivalent to (this, "p1", x => x)